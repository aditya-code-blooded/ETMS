(i)SQL Injection: Make sure no input from the user (either from the web form or url) has an impact on the database. Solution is to process the data before executing them

(ii)XSS: The essence of any XSS attack is the injection of code (usually JavaScript code but it can be any client-side code) into the output of your PHP script. This attack is possible when you display input that was sent to you, such as you would do with a forum posting for example. The attacker may post JavaScript code in his message that does unspeakable things to your site.
Cross-site scripting attacks can be grouped in two major categories, based on how they deliver the malicious payload: non-persistent XSS, and persistent XSS.
(a)Non-persistent XSS
Also known as reflected XSS attack, meaning that the actual malicious code is not stored on the server but rather gets passed through it and presented to the victim, is the more popular XSS strategy of the two delivery methods. The attack is launched from an external source, such as from an e-mail message or a third-party website.
(b)Persistent XSS
This type of attack happens when the malicious code has already slipped through the validation process and it is stored in a data store. This could be a comment, log file, notification message, or any other section on the website which required user input at one time. Later, when this particular information is presented on the website, the malicious code gets executed.
Example: Initially
<?php
file_put_contents("comments.txt", $_POST["comment"], FILE_APPEND);
Later
<?php
echo file_get_contents("comments.txt");
Prevention of XSS: The first rule which needs to be “enforced” in any web environment (be it development, staging, or production) is never trust data coming from the user or from any other third party sources. This can’t be emphasized enough. Every bit of data must be validated on input and escaped on output. This is the golden rule of preventing XSS. we should be mindful of data validation, data sanitization, and output escaping.

Data validation is the process of ensuring that your application is running with correct data. If your PHP script expects an integer for user input, then any other type of data would be discarded. Every piece of user data must be validated when it is received to ensure it is of the corrected type, and discarded if it doesn’t pass the validation process.

Data sanitization focuses on manipulating the data to make sure it is safe by removing any unwanted bits from the data and normalizing it to the correct form. For example, if you are expecting a plain text string as user input, you may want to remove any HTML markup from it.

In order to protect the integrity of displayed/output data, you should escape the data when presenting it to the user. This prevents the browser from applying any unintended meaning to any special sequence of characters that may be found.


(iii)Source Code Revelation: This one has to do with people being able to see the names and content of files they shouldn’t in the event of a breakdown in Apache’s configuration.
We all know that PHP is server side – you can’t just do a view source to see a script’s code. But if something happens to Apache and all of a sudden your scripts are served as plain text, people see source code they were never meant to see. Some of that code might list accessible configuration files or have sensitive information like database credentials.
The solution centers around how you set up the directory structure for your application. That is, it isn’t so much a problem that bad people can see some code, it’s what code they can see if sensitive files are kept in a public directory. Keep important files out of the publicly-accessible directory to avoid the consequences of this blunder.
In the README file, add the comment saying that "For securing from Source Code Revelation", put all the files (such as constants.js/php files outside the document root folder and update the symlinks in the source code wherever necessary)

(iv)Remote File Inclusion
Remote file inclusion is when remote files get included in your application. Suppose you have a situation where your site at www.myplace.com includes the library www.goodpeople.com/script.php. One night, www.goodpeople.com is compromised and the contents of the file is replaced with evil code that will trash your application. Then someone visits your site, you pull in the updated code, and Bam! So how do you stop it? All you have to do is go to your php.ini and check the settings on these flags.

	allow_url_fopen – indicates whether external files can be included. The default is to set this to ‘on’ but you want to turn this off.
	allow_url_include – indicates whether the include(), require(), include_once(), and require_once() functions can reference remote files. The default sets this off, and setting allow_url_fopen off forces this off too.

No security threat of this kind is present within our application. However, just have a look at all the script files.

(v)Session Hijacking
Session hijacking is when an attacker steals and use someone else’s session ID, which is something like a key to a safe deposit box. When a session is set up between a client and a web server, PHP will store the session ID in a cookie on the client side probably called PHPSESSID. Sending the ID with the page request gives you access to the session info persisted on the server (which populates the super global $_SESSION array).
Session IDs are commonly stolen via a XSS attack, so preventing those is a good thing that yields double benefits. It’s also important to change the session ID as often as is practical. This reduces your theft window. From within PHP you can run the session_regenerate_id() function to change the session ID and notify the client.

(vi)Directory Traversal
This attack, like so many of the others, looks for for a site where the security is not all that it should be, and when if finds one, it causes files to be accessed that the owner did not plan to make publicly accessible. It’s also known as the ../ (dot, dot, slash) attack, the climbing attack, and the backtracking attack. Protection: define what pages can be returned for a given request using whitelisting. Another option is to convert file paths to absolute paths and make sure they’re referencing files in allowed directories

(vii)Cross-site request forgery
(CSRF) is a common and serious exploit where a user is tricked into performing an action he didn’t explicitly intend to do. This can happen when, for example, the user is logged in to one of his favorite websites and proceeds to click a seemingly harmless link. In the background, his profile information is silently updated with an attacker’s e-mail address. The attacker can then use the website’s password reset feature to e-mail herself a new password and she’s just successfully stolen the account. Any action that a user is allowed to perform while logged in to a website, an attacker can perform on his/her behalf, whether it’s updating a profile, adding items to a shopping cart, posting messages on a forum, or practically anything else.

(viii)Denial of Service
There are three methods of denial of service (DoS), of which two are essentially the same:

A malicious user with a fast Internet connection bombards your web server with requests, thereby overloading it

A malicious user with accomplices, who may be unwitting, bombard your web server with requests, thereby overloading it. In this situation, the attackers do not need fast Internet connections - 100 requests from 10,000 people are as damaging as 1,000,000 requests from one person.

A malicious user finds a hole in your web site that forces your server to perform an inordinate amount of work, thereby overloading the server.

Of the three, the first two are impossible to defend against - the world's largest sites have been taken offline by this form of denial of service, and there is nothing you can do irrespective of whether you are using PHP.

The last option, however, is something you can guard against. If you have holes in your code that can be exploited by outsiders to cause your web server to chew up 99% of your CPU time, you are in trouble.

It is not yet implemented in our code. First when there are several user requests with incorrect password, then use sleep() function with a descriptive message. When deployed to real server, we can block the particular user who sends several requests

->Improvements
Using PDO (PHP Data Objects)
Object oriented version of PHP (Currently we used mysqli - with procedural paradigm)
Backend validation when front-end validation is turned off for few webpages within our application (graceful degradation) (If anyone required that after putting it in Github, say them to raise an issue or ping me. I'll implement. This feature is only for those who want to use this tool for their daily purposes)
Check whether we need to make a database call each and everytime. in sessions in php script

->Note
When the session is deleted manually by the user, then few errors are occurring. Fix em'.
Create an sql file to generate the entire database schema required for the application to work
Make sure that php files run on .html extension files
php.ini configuration for fileUploads